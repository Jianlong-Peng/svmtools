/*=============================================================================
#     FileName: svmtools.h
#         Desc: 
#       Author: jlpeng
#        Email: jlpeng1201@gmail.com
#     HomePage: 
#      Created: 2013-06-06 17:03:25
#   LastChange: 2013-07-08 13:25:46
#      History:
=============================================================================*/

#ifndef  SVMTOOLS_H
#define  SVMTOOLS_H

#define Malloc(type,n) (type *)malloc((n)*sizeof(type))

// ============================svm_problem===============================
// don't forget to free the returned variable using `free_svm_problem`!!!
struct svm_problem *read_svm_problem(const char *filename);
// to get a copy of `prob` by keeping those features with make[i] being 1.
// don't forget to free the returned variable using `free_svm_problem1`!!!!
struct svm_problem *copy_part_svm_problem(const struct svm_problem *prob, const int *mask);
// make a full copy of `prob`
// don't forget to free the returned variable using `free_svm_problem1`!!!!
struct svm_problem *copy_svm_problem(const struct svm_problem *prob);

void write_svm_problem(const struct svm_problem *prob, const char *outfile);
void display_svm_problem(const struct svm_problem *prob);

// prob: generated by 'read_svm_problem'
void free_svm_problem(struct svm_problem *prob);
// each prob->x[i] should be something created via `malloc`
void free_svm_problem1(struct svm_problem *prob);

// the following splitting methods are not hierarchical!!!!!
// - split samples according to 'itrain'
// - train, test: generated by 'allocate_svm_problem'
// - itrain[i]: 1 - as training sample; 0 - as test sample
void split_svm_problem(const struct svm_problem *prob, struct svm_problem *train, 
        struct svm_problem *test, int *itrain);
// randomly pick 'n' samples as train, and remaining as test
void random_split_problem(const struct svm_problem *prob, struct svm_problem *train, 
        struct svm_problem *test, int n);

// to make a copy of `prob`, and features with value 0 will be added.
// don't forget to destroy the returned variable using `free_svm_problem1`!!!!!!
struct svm_problem *copy_and_refine_problem(const struct svm_problem *prob);


// ============================svm_parameter=============================
struct svm_parameter* create_svm_parameter(int svm_type, int kernel_type);
struct svm_parameter* copy_svm_parameter(const struct svm_parameter *param);


double kernel(const struct svm_node *x, const struct svm_node *y, const struct svm_parameter *param, int ignore_tag);

int svm_num_features(const struct svm_problem *prob);


// ============================cross-validation==========================
// do LOO, and evaluation method 'eval' will be called on the predicted results
double svm_loo(const struct svm_parameter *para, const struct svm_problem *prob,
        double (*eval)(const double *act, const double *pred, int n));
// svm_cross_validation
double svm_nCV(const struct svm_parameter *para, const struct svm_problem *prob, int nfold,
        double (*eval)(const double *act, const double *pred, int n));

// ============================metrics===================================
double calcQ2(const double *act, const double *pred, int n);
double calcR2(const double *act, const double *pred, int n);
double calcMAE(const double *act, const double *pred, int n);

// ============================grid search===============================
// grid search for C, epsilon
// parameters are same as those passed to `grid_search_cpg`
double grid_search_cp(const struct svm_problem *prob, struct svm_parameter *para, int nfold, int verbose,
        double (*eval)(const double *act, const double *pred, int n));
// grid search for C, gamma, epsilon
// verbose: 1 - display information of each combination of `C, gamma, epsilon`
// eval: method to evaluate set of parameters. greater value is better
// `para` will be updated!!!!!!
// return value: estimated value of the best combination of `C, gamma, epsilon`
double grid_search_cpg(const struct svm_problem *prob, struct svm_parameter *para, int nfold, int verbose,
        double (*eval)(const double *act, const double *pred, int n));

#if defined(USE_THREAD)
extern int num_thread;
#endif

// ============================others====================================
// do not forget freeing the returned result!!!!!
// if you one to predict only one sample, please use 'svm_predict' instead!!!!
double *predict(const struct svm_model *model, const struct svm_problem *prob);

// ============================feature selection=========================
// Parameter
// - step: number of features to be removed each time.
// - num_pick: keep eliminating features until {num_pick} features remained.
// - nfold: {nfold}-fold CV will be used to estimate the selected feature subset
// - search: if !=0, grid search will be carried out to optimize parameters
// - importance: relative importance of each feature.
// - calcImportance: function to evaluate the relative importance of each feature.
//   (abandoned!)  if it's failure to estimate a feature's importance, then value 
//                 of `DBL_MIN` should be given.
// - evaluate: function to evaluate actual and predicted Ys
// Attention: feature importance is calculated at the very begining, and remained unchanged!!!!!!
void rfe(const struct svm_problem *prob, const struct svm_parameter *para,
        int step, int num_pick, int nfold, int search, double *importance,
        /*double *(*calcImportance)(const struct svm_problem *),*/
        double (*evaluate)(const double *act, const double *pred, int n));

#endif   /* ----- #ifndef SVMTOOLS_H  ----- */

